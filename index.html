<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pentaset</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            background: #000;
            font-family: "Yu Gothic UI", sans-serif;
        }
        canvas {
            display: block;
        }
        .overlay {
    position: absolute;
    top: 0;
    width: 100vw;
    height: 66vh; /* 2/3 of the height */
    background: rgba(0, 0, 0, 0.6); /* 50% transparent black */
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1;
}
.overlay-content {
    position: absolute;
    bottom: 64px; /* Space from the bottom */
    left: 128px;  /* Space from the left */
    text-align: left;
    display: flex;
    flex-direction: column;
    gap: 8px;
    max-width: 100vw; /* Ensures text doesn't overflow off-screen */
    overflow: hidden;
}

.overlay-text {
    font-size: 128px;
    font-weight: bold;
    color: white;
    line-height: 1.1;
    white-space: nowrap; /* Prevents text from wrapping */
    overflow: hidden;
    text-overflow: ellipsis; /* Adds "..." if text is too long */
}

.overlay-subtext {
    font-size: 32px;
    color: white;
    line-height: 1.3;
    white-space: nowrap; /* Prevents text from wrapping */
    overflow: hidden;
    text-overflow: ellipsis; /* Adds "..." if text is too long */
}
.footer-overlay {
    position: absolute;
    bottom: 0;
    width: 100vw;
    height: 6vh; /* Adjust height as needed */
    background: rgba(0, 0, 0, 0.8); /* 50% transparent black */
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1;
}
.footer-text {
    font-size: 16px; /* Smaller than the header text */
    color: white;
    text-align: center;
}

.footer-text a {
    color: #66CCFF; /* Matching the greenish color from your theme */
    text-decoration: none;
    font-weight: bold;
}

.footer-text a:hover {
    text-decoration: underline;
}
    </style>
</head>
<body>
    <canvas id="fluidCanvas"></canvas>

    <!-- Header Overlay -->
<div class="overlay">
    <div class="overlay-content">
        <div class="overlay-text">PENTASET</div>
        <div class="overlay-subtext">.NET development, BIM, FEM, Civil Engineering and more...</div>
    </div>
</div>

    <!-- Footer Overlay -->
    <div class="footer-overlay">
        <div class="footer-text">
            Contact: <a href="mailto:info@pentaset.net">info@pentaset.net</a> | Phone: +372 55 633 555
        </div>
    </div>

    <script>
        const canvas = document.getElementById('fluidCanvas');
        const ctx = canvas.getContext('2d');
        const colors = [
            ['#ff00ff', '#50c878'], // magenta & emerald green
            ['#0000ff', '#ffff00'], // blue & yellow
            ['#ff4500', '#008080'], // orange red & teal
            ['#8a2be2', '#00fa9a'], // blue violet & medium spring green
            ['#ff6347', '#4169e1'], // tomato & royal blue
        ];

        // Full screen canvas
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Function to get random color pair
        function getRandomColorPair() {
            const pair = colors[Math.floor(Math.random() * colors.length)];
            return pair;
        }

        const shapes = [];
        const shapesLayer1 = [];
        const shapesLayer2 = [];
        const shapesLayer3 = [];

        // Shape constructor with constant size
        function Shape(x, y, radius, color1, color2) {
            this.x = x;
            this.y = y;
            this.radius = radius;  // Fixed radius
            this.color1 = color1;
            this.color2 = color2;
            this.direction = Math.random() * Math.PI * 2;
            this.speed = Math.random() * 2 + 0.5;
        }

        // Shape update method to move it
        Shape.prototype.update = function() {
            this.x += Math.cos(this.direction) * this.speed;
            this.y += Math.sin(this.direction) * this.speed;

            // Bounce off the walls
            if (this.x - this.radius < 0 || this.x + this.radius > canvas.width) {
                this.direction = 2 * Math.PI / this.radius - this.direction;
            }
            if (this.y - this.radius < 0 || this.y + this.radius > canvas.height) {
                this.direction = -this.direction;
            }
        };

        // Shape draw method with blur effect
        Shape.prototype.draw = function(blur) {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius);
            gradient.addColorStop(0, this.color1);
            gradient.addColorStop(1, this.color2);

            // Apply blur effect to the shape
            ctx.filter = `blur(${blur}px)`;  // Adjust blur intensity

            ctx.fillStyle = gradient;
            ctx.fill();
        };

        // Create shapes for the main layer with fixed sizes
        function createShapes() {
            for (let i = 0; i < 32; i++) {  // 30 shapes for the main layer
                const colorPair = getRandomColorPair();
                const shape = new Shape(
                    Math.random() * canvas.width,
                    Math.random() * canvas.height,
                    Math.random() * 64 + 64,  // Constant radius between 64px and 128px
                    colorPair[0],
                    colorPair[1]
                );
                shapes.push(shape);
            }

            // Create shapes for layer 1 (slightly less blur)
            for (let i = 0; i < 24; i++) {  // 30 shapes for layer 1
                const colorPair = getRandomColorPair();
                const shape = new Shape(
                    Math.random() * canvas.width,
                    Math.random() * canvas.height,
                    Math.random() * 128 + 128,  // Constant radius
                    colorPair[0],
                    colorPair[1]
                );
                shapesLayer1.push(shape);
            }

            // Create shapes for layer 2 (even less blur)
            for (let i = 0; i < 16; i++) {  // 30 shapes for layer 2
                const colorPair = getRandomColorPair();
                const shape = new Shape(
                    Math.random() * canvas.width,
                    Math.random() * canvas.height,
                    Math.random() * 64 + 64,  // Constant radius
                    colorPair[0],
                    colorPair[1]
                );
                shapesLayer2.push(shape);
            }

	    // Create shapes for layer 3 (even less blur)
            for (let i = 0; i < 128; i++) {
                const colorPair = getRandomColorPair();
                const shape = new Shape(
                    Math.random() * canvas.width,
                    Math.random() * canvas.height,
                    Math.random() * 4 + 2,  // Constant radius
                    colorPair[1],
                    colorPair[0]
                );
                shapesLayer3.push(shape);
            }
        }

        // Main animation loop
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);  // Clear the canvas on every frame

            // Draw the original layer with highest blur
            shapes.forEach(shape => {
                shape.update();  // Update shape position
                shape.draw(128);  // High blur for the base layer
            });

            // Draw the first layer with medium blur
            shapesLayer1.forEach(shape => {
                shape.update();  // Update shape position
                shape.draw(64);  // Medium blur for the first layer
            });

            // Draw the second layer with low blur
            shapesLayer2.forEach(shape => {
                shape.update();  // Update shape position
                shape.draw(32);  // Low blur for the second layer
            });

            ctx.globalCompositeOperation = "color-dodge";

            // Draw the second layer with low blur
            shapesLayer3.forEach(shape => {
                shape.update();  // Update shape position
                shape.draw(1);  // Low blur for the third layer
            });

            ctx.globalCompositeOperation = "source-over";

            requestAnimationFrame(animate);  // Request the next frame for continuous animation
        }

        createShapes();  // Create the initial set of shapes for all layers
        animate();  // Start the animation loop
    </script>
</body>
</html>
